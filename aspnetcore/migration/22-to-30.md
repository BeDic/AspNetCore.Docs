---
title: Migrate from ASP.NET Core 2.2 to 3.0 Preview
author: tdykstra
description: Learn how to migrate an ASP.NET Core 2.2 project to ASP.NET Core 3.0.
ms.author: tdykstra
ms.custom: mvc
ms.date: 03/02/2019
uid: migration/22-to-30
---
# Migrate from ASP.NET Core 2.2 to 3.0 Preview 2

By [Scott Addie](https://github.com/scottaddie) and [Rick Anderson](https://twitter.com/RickAndMSFT)

This article explains how to update an existing ASP.NET Core 2.2 project to ASP.NET Core 3.0 preview 2.

[!INCLUDE[](~/includes/net-core-prereqs-all-3.0.md)]

## Update the project file

* Set the [Target Framework Moniker (TFM)](/dotnet/standard/frameworks#referring-to-frameworks) to `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Remove any `<PackageReference>` to the [Microsoft.AspNetCore.All](xref:fundamentals/metapackage) or [Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app) metapackage.

* Update the `Version` on remaining `<PackageReference>` elements for `Microsoft.AspNetCore.*` packages to the current preview (for example, 3.0.0-preview-18579-0053).

  If there is no 3.0 version of a package, the package might have been deprecated in 3.0. Many of these are part of `Microsoft.AspNetCore.App` and should not be referenced individually anymore. For a preliminary list of packages no longer produced in 3.0, see [aspnet/AspNetCore #3756](https://github.com/aspnet/AspNetCore/issues/3756).

* Some assemblies were removed from `Microsoft.AspNetCore.App` between 2.x and 3.0. You may need to add `<PackageReference>` items if you're using APIs from packages listed in [aspnet/AspNetCore #3755](https://github.com/aspnet/AspNetCore/issues/3755).

  For example, `Microsoft.EntityFrameworkCore` and `System.Data.SqlClient` are no longer part of `Microsoft.AspNetCore.App`. The list of assemblies shipping in `Microsoft.AspNetCore.App` hasn't been finalized yet and will change before 3.0 RTM.

* Add [Json.NET support](#json).

* Projects default to the [in-process hosting model](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) in ASP.NET Core 3.0 or later. You may optionally remove the `<AspNetCoreHostingModel>` element if its value is `InProcess`.

<a name="json"></a>

## Json.NET support

As part of the work to [improve the ASP.NET Core shared framework](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) has been removed from the ASP.NET Core shared framework.

To use Json.NET in an ASP.NET Core 3.0 project:

* Add a package reference to [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)
* Update `ConfigureServices` to call `AddNewtonsoftJson()`.

    ```csharp
    services.AddMvc()
        .AddNewtonsoftJson();
    ```

Newtonsoft settings can be set with `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## MVC service registration

ASP.NET Core 3.0 adds some new options for registering MVC's various features inside `ConfigureServices`.

We're adding three new top level extension methods related to MVC features on `IServiceCollection`. Along with this change we are updating our templates to use these new methods instead of `UseMvc()`.

*`AddMvc()` is not being removed and will continue to behave as it does today.*

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Adds support for controllers and API-related features - but not views or pages.
    //
    // Used by the API template.
    services.AddControllers();
}
```

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Adds support for controllers, API-related features, and views - but not pages.
    //
    // Used by the Web Application (MVC) template.
    services.AddControllersWithViews();
}
```

```C#
public void ConfigureServices(IServiceCollection services)
{
    // Adds support for Razor Pages and minimal controller support.
    //
    // Used by the Web Application template.
    services.AddRazorPages();
}
```

These new methods can also be combined. This example is equivalent to the current `AddMvc()`. 

```C#
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## Update routing startup code

If your application uses `UseMvc()` or `UseSignalR()` then you should migrate to use Endpoint Routing if possible. We have reverted intentional changes in behavior in URL generation from 2.2 and fixed issues to make Endpoint Routing more compatible with previous versions of MVC. If you had problems using this feature in 2.2 you should expect to see things much improved with the following exceptions:

**Note:** If you implement `IRouter` or inherit from `Route` you may want to avoid migrating for now. We are collecting feedback around these scenarios [here](https://github.com/aspnet/AspNetCore/issues/4221) and would love to hear from you.

**Note:** If you directly access `RouteData.Routers` inside MVC you may want to avoid migrating for now. We are collecting feedback around these scenarios [here](https://github.com/aspnet/AspNetCore/issues/9148) and would love to hear from you.

Endpoint Routing supports the same route pattern syntax and route pattern authoring features as `IRouter`. Endpoint Routing supports `IRouteContraint`. Endpoint routing supports `[Route]`, `[HttpGet]` and the other MVC routing attributes.

For most applications, only `Startup.cs` will require changes.

### Migrating Configure()

General advice:

- Add `UseRouting()`. 
- If you have `UseStaticFiles()` then place `UseStaticFiles()` **before** `UseRouting()`.
- If you are using authentication/authorization features such as `AuthorizePage()` or `[Authorize]` then place the `UseAuthentication()` and `UseAuthorization()` **after** `UseRouting()` .
- If you are using CORS features like `[EnableCors]` then place `UseCors()` next.
- Replace `UseMvc` or `UseSignalR` with `UseEndpoints()`.


**Before:**

```C#
public void Configure(IApplicationBuilder app)
{
    ... 


    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

**After:**

```C#
public void Configure(IApplicationBuilder app)
{
    ... 

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```


### Security middleware guidance

We are unifying the support for authorization and CORS around the middleware approach. This allows us to use the same middleware and functionality across different scenarios. We have added an authorization middleware in this release, and have enhance the CORS middleware so that it can understand the attributes used in MVC Controllers.

#### CORS

Previously our guidance for CORS was hard to understand, as we provided a middleware for use in some cases, and also MVC filters that were intended to be used **without** the middleware. Our recommendation now is that all applications that need CORS should use the CORS middleware in tandem with Endpoint Routing. `UseCors()` can be provided with a default policy, and `[EnableCors]` and `[DisableCors]` attributes can be used with frameworks to override the default policy. 

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); // Enable CORS for all endpoints with named policy "default".

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors] // Disable CORS for this controller
public class MyController : ControllerBase
{
    ...
}
```

#### Authorization

Previously we provided authorization support only via the `[Authorize]` attribute in MVC and SignalR - and we did not provide an authorization middleware. Now the new authorization middleware is required for these cases. We recommend putting the `UseAuthentication()` middleware right before `UseAuthorization()` for simplicity. The `UseAuthorization()` middleware can also be configured with a default policy that will be applied unless overridden.

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    ...

    [Authorize] // Require a logged-in user
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

If you previously used an `AuthorizeFilter` as a global filter in MVC, we recommend providing a policy instead to the `UseAuthorization()` middleware.

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build())); // Provide a custom policy to be applied to all requests.

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous] // Allow access without being logged in
public class HomeController : ControllerBase
{
    ...
}
```

Authorization by middleware works without the framework having any specific knowledge of authorization. For instance, health checks has no specific knowledge of authorization, but can have a configurable authorization policy applied by the middleware.

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(); // Process authorization but don't add a default policy

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

The new version of startup might be just slightly more verbose than previous versions, but we think it is much more powerful, and the guidance is more straightforward. 

In preview 4 we've implemented some protection since the recommended pattern is changing. We don't want applications to become less secure because the framework changed, so the `UseEndpoint()` middleware will throw an exception if an authorization or CORS policy was skipped due to missing middleware. We're working on analyzer support to provide more immediate feedback about misconfiguration.


### Migrating SignalR

Mapping of SignalR hubs now takes place inside `UseEndpoints`. 

Map each hub with `MapHub<>()` - as before, each hub must be explicitly listed. 

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>(); // Adds support for the ChatHub SignalR hub.
    });
}
```


### Migrating MVC controllers

Mapping of controllers now takes place inside `UseEndpoints`. 

Add `MapControllers()` if you are using attribute routing - since routing now includes support for many frameworks, adding attribute routed controllers is now opt-in. 

Replace `MapRoute()` with `MapControllerRoute()` and `MapAreaRoute()` with `MapAreaControllerRoute()`. Since routing now includes support for more than just MVC the terminology has changed to make these methods more clearly state what they do. Conventional routes such as `MapControllerRoute()`/`MapAreaControllerRoute()`/`MapDefaultControllerRoute()` are applied in the order they are added. Always place more specific routes (such as routes for an area) first.

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers(); // Adds support for attribute-routed controllers

        endpoints.MapAreaControllerRoute("admin", "admin", "Admin/{controller=Home}/{action=Index}/{id?}"); // Adds a conventional route for controllers in an area.
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}"); // Adds a conventional route for controllers.
    });
}
```


### Migrating Razor Pages

Mapping pages now takes place include `UseEndpoints`.

Add `MapRazorPages()` if you are using pages - since routing now includes support for many frameworks, adding Razor Pages is now opt-in. 

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages(); // Adds support for Razor Pages
    });
}
```


### Using MVC without Endpoint Routing

Using MVC via `UseMvc()` or `UseMvcWithDefaultRoute()` in 3.0 requires an explicit opt-in inside `ConfigureServices()`. This is required because MVC needs to know whether it can rely on the Authorization and CORS middleware during initialization. We've provided an analyzer that will warn if you attempt to use an unsupported configuration.

If you need to continue using legacy `IRouter` support for any reason you can do this by setting `EnableEndpointRouting` to false.

```C#
public class Startup()
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc(options => options.EnableEndpointRouting = false);

        // OR

        services.AddControllers(options => options.EnableEndpointRouting = false);

        // OR

        services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

        // OR

        services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
    }

    public void Configure(IApplicationBuilder app)
    {
        ...

        app.UseMvc();
    }
}
```


### Migrating health checks

Health checks can now be used as a *router-ware* with Endpoint Routing.

Add `MapHealthChecks()` to use health checks with Endpoint Routing. The `MapHealthChecks()` method accepts arguments similar to `UseHealthChecks()`. The advantage of using `MapHealthChecks()` over `UseHealthChecks()` is the ability to apply authorization, and to have more fine-grained control over the matching policy. 

```C#
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { }); // Adds a health check endpoint
    });
}
```

## HostBuilder replaces WebHostBuilder

The ASP.NET Core 3.0 templates use [Generic Host](xref:fundamentals/host/generic-host). Previous versions used [Web Host](xref:fundamentals/host/web-host). The following code shows the ASP.NET Core 3.0 template generated `Program` class:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

The following code shows the ASP.NET Core 2.2 template-generated `Program` class:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> remains in 3.0 and is the type of the `webBuilder` seen in the preceding code sample. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> will be deprecated in a future release and replaced by `HostBuilder`.

The most significant change from `WebHostBuilder` to `HostBuilder` is in [dependency injection (DI)](xref:fundamentals/dependency-injection). When using `HostBuilder`, you can only inject <xref:Microsoft.Extensions.Configuration.IConfiguration> and <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> into `Startup`'s constructor. The `HostBuilder` DI constraints:

* Enable the DI container to be built only one time.
* Avoids the resulting object lifetime issues like resolving multiple instances of singletons.

## Update SignalR code

If you call `AddJsonProtocol`, replace it with `AddNewtonsoftJsonProtocol`.

* The following examples show server code before and after the change:

  ```csharp
  services.AddSignalR(...)
          .AddJsonProtocol(...) // 2.2
  ```

  ```csharp
  services.AddSignalR(...)
          .AddNewtonsoftJsonProtocol(...) // 3.0
  ```

* The following examples show .NET client code before and after the change:

  ```csharp
  connection = new HubConnectionBuilder()
      .WithUrl(...)
      .AddJsonProtocol(...) // 2.2
      .Build()
  ```

  ```csharp
  connection = new HubConnectionBuilder()
      .WithUrl(...)
      .AddNewtonsoftJsonProtocol(...) // 3.0
      .Build()
  ```

## Opt in to runtime compilation

In 3.0, runtime compilation is an opt-in scenario. To enable runtime compilation, see <xref:mvc/views/view-compilation#runtime-compilation>.
